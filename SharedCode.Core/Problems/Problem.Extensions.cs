using System.Net;
using System.Text.Json.Serialization;

namespace SharedCode.Problems;

public partial class Problem
{
	/// <summary>
	/// Custom error code stored in Extensions.
	/// </summary>
	[JsonIgnore]
	public string ErrorCode
	{
		get
		{
			if (this.Extensions.TryGetValue(ProblemConstants.ExtensionKeys.ErrorCode, out var code))
			{
				// Handle JsonElement from deserialization
				return code is JsonElement jsonElement ? jsonElement.GetString() ?? string.Empty : code?.ToString() ?? string.Empty;
			}

			return string.Empty;
		}
		set
		{
			if (string.IsNullOrEmpty(value))
			{
				_ = this.Extensions.Remove(ProblemConstants.ExtensionKeys.ErrorCode);
			}
			else
			{
				this.Extensions[ProblemConstants.ExtensionKeys.ErrorCode] = value;
			}
		}
	}

	/// <summary>
	/// Creates a Problem with title and detail.
	/// </summary>
	/// <param name="title">
	/// A short, human-readable summary of the problem type.
	/// </param>
	/// <param name="detail">
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </param>
	public static Problem Create(string title, string detail)
	{
		return new Problem
		{
			Type = ProblemConstants.Types.HttpStatus(500),
			Title = title,
			StatusCode = 500,
			Detail = detail
		};
	}

	/// <summary>
	/// Creates a Problem with title, detail and status code.
	/// </summary>
	/// <param name="title">
	/// A short, human-readable summary of the problem type.
	/// </param>
	/// <param name="detail">
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </param>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	public static Problem Create(string title, string detail, int statusCode)
	{
		return new Problem
		{
			Type = ProblemConstants.Types.HttpStatus(statusCode),
			Title = title,
			StatusCode = statusCode,
			Detail = detail
		};
	}

	/// <summary>
	/// Creates a Problem with title, detail and HttpStatusCode.
	/// </summary>
	/// <param name="title">
	/// A short, human-readable summary of the problem type.
	/// </param>
	/// <param name="detail">
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </param>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	public static Problem Create(string title, string detail, HttpStatusCode statusCode)
	{
		return new Problem
		{
			Type = ProblemConstants.Types.HttpStatus((int)statusCode),
			Title = title,
			StatusCode = (int)statusCode,
			Detail = detail
		};
	}

	/// <summary>
	/// Creates a Problem with title, detail, status code and type.
	/// </summary>
	/// <param name="title">
	/// A short, human-readable summary of the problem type.
	/// </param>
	/// <param name="detail">
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </param>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	/// <param name="type">
	/// A URI reference that identifies the problem type. This specification encourages that,
	/// </param>
	public static Problem Create(string title, string detail, int statusCode, string type)
	{
		return new Problem
		{
			Type = type,
			Title = title,
			StatusCode = statusCode,
			Detail = detail
		};
	}

	/// <summary>
	/// Creates a Problem with all fields.
	/// </summary>
	/// <param name="title">
	/// A short, human-readable summary of the problem type.
	/// </param>
	/// <param name="detail">
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </param>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	/// <param name="type">
	/// A URI reference that identifies the problem type. This specification encourages that,
	/// </param>
	/// <param name="instance">
	/// A URI reference that identifies the specific occurrence of the problem. It may or
	/// not yield further information if dereferenced.
	/// </param>
	public static Problem Create(string title, string detail, int statusCode, string type, string instance)
	{
		return new Problem
		{
			Type = type,
			Title = title,
			StatusCode = statusCode,
			Detail = detail,
			Instance = instance
		};
	}

	/// <summary>
	/// Creates a Problem from an HTTP status code.
	/// </summary>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	public static Problem Create(HttpStatusCode statusCode)
	{
		return new Problem
		{
			Type = ProblemConstants.Types.HttpStatus((int)statusCode),
			Title = statusCode.ToString(),
			StatusCode = (int)statusCode,
			Detail = statusCode.ToString()
		};
	}

	/// <summary>
	/// Creates a Problem from an HTTP status code with detail.
	/// </summary>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	/// <param name="detail">
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </param>
	public static Problem Create(HttpStatusCode statusCode, string detail)
	{
		return new Problem
		{
			Type = ProblemConstants.Types.HttpStatus((int)statusCode),
			Title = statusCode.ToString(),
			StatusCode = (int)statusCode,
			Detail = detail
		};
	}

	/// <summary>
	/// Creates a Problem from a custom error enum.
	/// </summary>
	/// <param name="errorCode">
	/// A custom error code represented as an enum. The enum's numeric value will be used as the
	/// status code if it falls within the HTTP status code range (100-599).
	/// </param>
	/// <typeparam name="TEnum">
	/// The type of the custom error enum. It must be an enum type.
	/// </typeparam>
	[SuppressMessage("Design", "GCop179:Do not hardcode numbers, strings or other values. Use constant fields, enums, config files or database as appropriate.", Justification = "<Pending>")]
	public static Problem Create<TEnum>(TEnum errorCode) where TEnum : Enum
	{
		// Try to get the enum's numeric value as status code
		var enumValue = Convert.ToInt32(errorCode, CultureInfo.CurrentCulture);

		// If the enum value looks like an HTTP status code (100-599), use it Otherwise default
		// to 400 Bad Request for domain errors
		var statusCode = (enumValue is >= 100 and <= 599) ? enumValue : 400;

		var problem = new Problem
		{
			Type = ProblemConstants.Types.HttpStatus(statusCode),
			Title = errorCode.ToString(),
			StatusCode = statusCode,
			Detail = $"{ProblemConstants.Messages.GenericError}: {errorCode}",
			ErrorCode = errorCode.ToString()
		};
		problem.Extensions[ProblemConstants.ExtensionKeys.ErrorType] = typeof(TEnum).Name;

		return problem;
	}

	/// <summary>
	/// Creates a Problem from a custom error enum with detail.
	/// </summary>
	/// <typeparam name="TEnum">
	/// The type of the custom error enum. It must be an enum type.
	/// </typeparam>
	/// <param name="errorCode">
	/// A custom error code represented as an enum. The enum's numeric value will be used as the
	/// status code if it falls within the HTTP status code range (100-599).
	/// </param>
	/// <param name="detail">
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </param>
	[SuppressMessage("Design", "GCop179:Do not hardcode numbers, strings or other values. Use constant fields, enums, config files or database as appropriate.", Justification = "<Pending>")]
	public static Problem Create<TEnum>(TEnum errorCode, string detail) where TEnum : Enum
	{
		// Try to get the enum's numeric value as status code
		var enumValue = Convert.ToInt32(errorCode, CultureInfo.CurrentCulture);

		// If the enum value looks like an HTTP status code (100-599), use it Otherwise default
		// to 400 Bad Request for domain errors
		var statusCode = (enumValue is >= 100 and <= 599) ? enumValue : 400;

		var problem = new Problem
		{
			Type = ProblemConstants.Types.HttpStatus(statusCode),
			Title = errorCode.ToString(),
			StatusCode = statusCode,
			Detail = detail,
			ErrorCode = errorCode.ToString()
		};
		problem.Extensions[ProblemConstants.ExtensionKeys.ErrorType] = typeof(TEnum).Name;

		return problem;
	}

	/// <summary>
	/// Creates a Problem from a custom error enum with explicit status code.
	/// </summary>
	/// <typeparam name="TEnum">
	/// The type of the custom error enum. It must be an enum type.
	/// </typeparam>
	/// <param name="errorCode">
	/// A custom error code represented as an enum. The enum's numeric value will be used as the
	/// status code if it falls within the HTTP status code range (100-599).
	/// </param>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	public static Problem Create<TEnum>(TEnum errorCode, int statusCode) where TEnum : Enum
	{
		var result = new Problem
		{
			Type = ProblemConstants.Types.HttpStatus(statusCode),
			Title = errorCode.ToString(),
			StatusCode = statusCode,
			Detail = $"{ProblemConstants.Messages.GenericError}: {errorCode}",
			ErrorCode = errorCode.ToString()
		};
		result.Extensions[ProblemConstants.ExtensionKeys.ErrorType] = typeof(TEnum).Name;

		return result;
	}

	/// <summary>
	/// Creates a Problem from a custom error enum with detail and status code.
	/// </summary>
	/// <typeparam name="TEnum">
	/// The type of the custom error enum. It must be an enum type.
	/// </typeparam>
	/// <param name="errorCode">
	/// A custom error code represented as an enum. The enum's numeric value will be used as the
	/// status code if it falls within the HTTP status code range (100-599).
	/// </param>
	/// <param name="detail">
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </param>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	public static Problem Create<TEnum>(TEnum errorCode, string detail, int statusCode) where TEnum : Enum
	{
		var result = new Problem
		{
			Type = ProblemConstants.Types.HttpStatus(statusCode),
			Title = errorCode.ToString(),
			StatusCode = statusCode,
			Detail = detail,
			ErrorCode = errorCode.ToString()
		};
		result.Extensions[ProblemConstants.ExtensionKeys.ErrorType] = typeof(TEnum).Name;

		return result;
	}

	/// <summary>
	/// Creates a Problem from an exception.
	/// </summary>
	/// <param name="exception">
	/// The exception to create a Problem from. This should be an instance of
	/// <see cref="Exception"/> or a derived type that contains relevant error information.
	/// </param>
	/// <exception cref="ArgumentNullException">exception</exception>
	public static Problem Create(Exception exception)
	{
#if NET6_0_OR_GREATER
		ArgumentNullException.ThrowIfNull(exception);
#else
		if (exception is null)
		{
			throw new ArgumentNullException(nameof(exception));
		}
#endif

		var problem = new Problem
		{
			Type = ProblemConstants.Types.HttpStatus(500),
			Title = exception.GetType().Name,
			Detail = exception.Message,
			StatusCode = 500,
			ErrorCode = exception.GetType().FullName ?? exception.GetType().Name
		};

		// Store the original exception type for potential reconstruction
		problem.Extensions[ProblemConstants.ExtensionKeys.OriginalExceptionType] = exception.GetType().FullName;

		if (exception.Data.Count > 0)
		{
			foreach (var key in exception.Data.Keys)
			{
				if (key is not null)
				{
					problem.Extensions[$"{ProblemConstants.ExtensionKeys.ExceptionDataPrefix}{key}"] = exception.Data[key];
				}
			}
		}

		return problem;
	}

	/// <summary>
	/// Creates a Problem from an exception with HttpStatusCode.
	/// </summary>
	/// <param name="exception">
	/// The exception to create a Problem from. This should be an instance of
	/// <see cref="Exception"/> or a derived type that contains relevant error information.
	/// </param>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	public static Problem Create(Exception exception, HttpStatusCode statusCode) => Create(exception, (int)statusCode);

	/// <summary>
	/// Creates a Problem from an exception with status code.
	/// </summary>
	/// <param name="exception">
	/// The exception to create a Problem from. This should be an instance of
	/// <see cref="Exception"/> or a derived type that contains relevant error information.
	/// </param>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	/// <exception cref="ArgumentNullException">exception</exception>
	public static Problem Create(Exception exception, int statusCode)
	{
#if NET6_0_OR_GREATER
		ArgumentNullException.ThrowIfNull(exception);
#else
		if (exception is null)
		{
			throw new ArgumentNullException(nameof(exception));
		}
#endif

		var result = new Problem
		{
			Type = ProblemConstants.Types.HttpStatus(statusCode),
			Title = exception.GetType().Name,
			Detail = exception.Message,
			StatusCode = statusCode,
			ErrorCode = exception.GetType().FullName ?? exception.GetType().Name
		};

		// Store the original exception type for potential reconstruction
		result.Extensions[ProblemConstants.ExtensionKeys.OriginalExceptionType] = exception.GetType().FullName;

		if (exception.Data.Count > 0)
		{
			foreach (var key in exception.Data.Keys)
			{
				if (key is not null)
				{
					result.Extensions[$"{ProblemConstants.ExtensionKeys.ExceptionDataPrefix}{key}"] = exception.Data[key];
				}
			}
		}

		return result;
	}

	/// <summary>
	/// Creates a Problem from a custom error enum.
	/// </summary>
	/// <typeparam name="TEnum">
	/// The type of the custom error enum. It must be an enum type.
	/// </typeparam>
	/// <param name="errorCode">
	/// A custom error code represented as an enum. The enum's numeric value will be used as the
	/// HTTP status code for this occurrence of the problem.
	/// </param>
	public static Problem FromEnum<TEnum>(TEnum errorCode) where TEnum : Enum => Create(errorCode);

	/// <summary>
	/// Creates a Problem from a custom error enum with detail.
	/// </summary>
	/// <typeparam name="TEnum">
	/// The type of the custom error enum. It must be an enum type.
	/// </typeparam>
	/// <param name="errorCode">
	/// A custom error code represented as an enum. The enum's numeric value will be used as the
	/// HTTP status code for this occurrence of the problem.
	/// </param>
	/// <param name="detail">
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </param>
	public static Problem FromEnum<TEnum>(TEnum errorCode, string detail) where TEnum : Enum => Create(errorCode, detail);

	/// <summary>
	/// Creates a Problem from a custom error enum with detail and explicit status code.
	/// </summary>
	/// <typeparam name="TEnum">
	/// The type of the custom error enum. It must be an enum type.
	/// </typeparam>
	/// <param name="errorCode">
	/// A custom error code represented as an enum. The enum's numeric value will be used as the
	/// HTTP status code for this occurrence of the problem.
	/// </param>
	/// <param name="detail">
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </param>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	public static Problem FromEnum<TEnum>(TEnum errorCode, string detail, int statusCode) where TEnum : Enum => Create(errorCode, detail, statusCode);

	/// <summary>
	/// Creates a Problem from an exception.
	/// </summary>
	/// <param name="exception">
	/// The exception to create a Problem from. This should be an instance of
	/// <see cref="Exception"/> or a derived type that contains relevant error information.
	/// </param>
	public static Problem FromException(Exception exception) => Create(exception);

	/// <summary>
	/// Creates a Problem from an exception with the status code.
	/// </summary>
	/// <param name="exception">
	/// The exception to create a Problem from. This should be an instance of
	/// <see cref="Exception"/> or a derived type that contains relevant error information.
	/// </param>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	public static Problem FromException(Exception exception, int statusCode) => Create(exception, statusCode);

	/// <summary>
	/// Creates a Problem from an HTTP status code.
	/// </summary>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	public static Problem FromStatusCode(HttpStatusCode statusCode) => Create(statusCode);

	/// <summary>
	/// Creates a Problem from an HTTP status code with detail.
	/// </summary>
	/// <param name="statusCode">
	/// The HTTP status code generated by the origin server for this occurrence of the problem.
	/// </param>
	/// <param name="detail">
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </param>
	public static Problem FromStatusCode(HttpStatusCode statusCode, string detail) => Create(statusCode, detail);

	/// <summary>
	/// Creates a validation Problem with errors.
	/// </summary>
	/// <param name="errors">
	/// A list of validation errors, each represented as a tuple containing the field name and error message.
	/// </param>
	public static Problem Validation(params (string field, string message)[] errors)
	{
		var problem = new Problem
		{
			Type = ProblemConstants.Types.ValidationFailed,
			Title = ProblemConstants.Titles.ValidationFailed,
			StatusCode = (int)HttpStatusCode.BadRequest,
			Detail = ProblemConstants.Messages.ValidationErrors
		};

		var errorDict = new Dictionary<string, List<string>>();
		foreach (var (field, message) in errors ?? [])
		{
			if (!errorDict.TryGetValue(field, out var value))
			{
				value = [];
				errorDict[field] = value;
			}

			value.Add(message);
		}

		problem.Extensions[ProblemConstants.ExtensionKeys.Errors] = errorDict;
		return problem;
	}

	/// <summary>
	/// Adds a validation error for a specific field.
	/// </summary>
	/// <param name="field">
	/// The name of the field that has a validation error.
	/// </param>
	/// <param name="message">
	/// A human-readable message describing the validation error for the field.
	/// </param>
	[SuppressMessage("Refactoring", "GCop628:Maybe define this method on '{0}' class as it's using {1} of its members (compared to {2} from this type)", Justification = "<Pending>")]
	public void AddValidationError(string field, string message)
	{
		if (!this.Extensions.TryGetValue(ProblemConstants.ExtensionKeys.Errors, out var errorsObj) ||
			errorsObj is not Dictionary<string, List<string>> errors)
		{
			errors = [];
			this.Extensions[ProblemConstants.ExtensionKeys.Errors] = errors;
		}

		if (!errors.TryGetValue(field, out var fieldErrors))
		{
			fieldErrors = [];
			errors[field] = fieldErrors;
		}

		fieldErrors.Add(message);
	}

	/// <summary>
	/// Gets error code as enum if possible.
	/// </summary>
	/// <typeparam name="TEnum">
	/// The type of the custom error enum. It must be a struct and an enum type.
	/// </typeparam>
	[SuppressMessage("Style", "GCop436:As the implementation is relatively long, change this into a standard method implementation.", Justification = "<Pending>")]
	public TEnum? GetErrorCodeAs<TEnum>() where TEnum : struct, Enum =>
		!string.IsNullOrEmpty(this.ErrorCode) &&
		Enum.TryParse<TEnum>(this.ErrorCode, out var result) ? result : null;

	/// <summary>
	/// Gets validation errors if any.
	/// </summary>
	public Dictionary<string, List<string>>? GetValidationErrors()
	{
		if (this.Extensions.TryGetValue(ProblemConstants.ExtensionKeys.Errors, out var errors))
		{
			// Handle direct dictionary
			if (errors is Dictionary<string, List<string>> dict)
			{
				return dict;
			}

			// Handle JsonElement from deserialization
			if (errors is JsonElement jsonElement)
			{
				var result = new Dictionary<string, List<string>>();
				foreach (var property in jsonElement.EnumerateObject())
				{
					var list = new List<string>();
					if (property.Value.ValueKind == JsonValueKind.Array)
					{
						foreach (var item in property.Value.EnumerateArray())
						{
							list.Add(item.GetString() ?? string.Empty);
						}
					}

					result[property.Name] = list;
				}

				return result;
			}
		}

		return null;
	}

	/// <summary>
	/// Checks if this problem has a specific error code.
	/// </summary>
	/// <typeparam name="TEnum">
	/// The type of the custom error enum. It must be an enum type.
	/// </typeparam>
	/// <param name="errorCode">
	/// The custom error code to check against the Problem's ErrorCode.
	/// </param>
	public bool HasErrorCode<TEnum>(TEnum errorCode) where TEnum : Enum => !string.IsNullOrEmpty(this.ErrorCode) && this.ErrorCode == errorCode.ToString();

	/// <summary>
	/// Converts the Problem to an exception, attempting to reconstruct the original exception
	/// type if possible.
	/// </summary>
	[SuppressMessage("Design", "CA1031:Do not catch general exception types", Justification = "<Pending>")]
	[SuppressMessage("Style", "IDE0045:Convert to conditional expression", Justification = "<Pending>")]
	public Exception ToException()
	{
		// Check if we have the original exception type stored
		if (this.Extensions.TryGetValue(ProblemConstants.ExtensionKeys.OriginalExceptionType, out var originalTypeObj) &&
			originalTypeObj is string originalTypeName)
		{
			try
			{
				// Try to get the type from the current app domain
				var originalType = System.Type.GetType(originalTypeName);

				// If not found, search in all loaded assemblies
				if (originalType is null)
				{
					foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
					{
						originalType = assembly.GetType(originalTypeName.Split(',')[0]);
						if (originalType is not null)
							break;
					}
				}

				if (originalType is not null && typeof(Exception).IsAssignableFrom(originalType))
				{
					// Try to create instance of the original exception type
					string message;
					if (string.IsNullOrEmpty(this.Detail))
					{
						message = string.IsNullOrEmpty(this.Title) ? "An error occurred" : this.Title!;
					}
					else
					{
						message = this.Detail!;
					}

					if (Activator.CreateInstance(originalType, message) is Exception reconstructedException)
					{
						// Restore any exception data
						foreach (var kvp in this.Extensions)
						{
							if (kvp.Key.StartsWith(ProblemConstants.ExtensionKeys.ExceptionDataPrefix, StringComparison.Ordinal))
							{
								var dataKey = kvp.Key[ProblemConstants.ExtensionKeys.ExceptionDataPrefix.Length..];
								reconstructedException.Data[dataKey] = kvp.Value;
							}
						}

						return reconstructedException;
					}
				}
			}
			catch
			{
				// No logging is needed
				// If reconstruction fails, fall back to ProblemException
			}
		}

		// Default to ProblemException
		return new ProblemException(this);
	}

	/// <summary>
	/// Creates a copy of this Problem with the specified extensions added.
	/// </summary>
	/// <param name="additionalExtensions">The additional extensions to add.</param>
	public Problem WithExtensions(IDictionary<string, object?> additionalExtensions)
	{
		var problem = new Problem
		{
			Type = this.Type,
			Title = this.Title,
			StatusCode = this.StatusCode,
			Detail = this.Detail,
			Instance = this.Instance
		};

		// Copy existing extensions
		foreach (var extension in this.Extensions)
		{
			problem.Extensions[extension.Key] = extension.Value;
		}

		// Add new extensions
		foreach (var extension in additionalExtensions ?? Enumerable.Empty<KeyValuePair<string, object?>>())
		{
			problem.Extensions[extension.Key] = extension.Value;
		}

		return problem;
	}

	/// <summary>
	/// Gets or creates validation errors dictionary.
	/// </summary>
	private Dictionary<string, List<string>> GetOrCreateValidationErrors()
	{
		if (!this.Extensions.TryGetValue(ProblemConstants.ExtensionKeys.Errors, out var errorsObj) ||
			errorsObj is not Dictionary<string, List<string>> errors)
		{
			errors = [];
			this.Extensions[ProblemConstants.ExtensionKeys.Errors] = errors;
		}

		return errors;
	}
}
