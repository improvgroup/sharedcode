using System.Text.Json.Serialization;

namespace SharedCode.Problems;
/// <summary>
/// A machine-readable format for specifying errors in HTTP API responses based on <see href="https://tools.ietf.org/html/rfc7807"/>.
/// </summary>
[JsonConverter(typeof(ProblemJsonConverter))]
[SuppressMessage("Design", "GCop179:Do not hardcode numbers, strings or other values. Use constant fields, enums, config files or database as appropriate.", Justification = "<Pending>")]
public partial class Problem
{
	/// <summary>
	/// Initializes a new instance of the <see cref="Problem"/> class.
	/// </summary>
	public Problem() => this.Extensions = new Dictionary<string, object?>(StringComparer.Ordinal);

	/// <summary>
	/// Initializes a new instance of the <see cref="Problem"/> class with the specified extensions.
	/// </summary>
	/// <param name="extensions">
	/// A dictionary of extension members to be added to the problem details.
	/// </param>
	/// <remarks>Alternative constructor that ensures Extensions is properly initialized</remarks>
	internal Problem(IDictionary<string, object?> extensions) : this()
	{
		if (extensions is not null)
		{
			foreach (var kvp in extensions)
			{
				this.Extensions[kvp.Key] = kvp.Value;
			}
		}
	}

	/// <summary>
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-2)]
	[JsonPropertyName("detail")]
	public string? Detail { get; set; }

	/// <summary>
	/// Gets the <see cref="IDictionary{TKey,TValue}"/> for extension members.
	/// <para>
	/// Problem type definitions MAY extend the problem details object with additional members.
	/// Extension members appear in the same namespace as other members of a problem type.
	/// </para>
	/// </summary>
	/// <remarks>
	/// The round-tripping behavior for <see cref="Extensions"/> is determined by the
	/// implementation of the Input \ Output formatters. In particular, complex types or
	/// collection types may not round-trip to the original type when using the built-in JSON or
	/// XML formatters.
	/// </remarks>
	[JsonExtensionData]
	public IDictionary<string, object?> Extensions { get; } = new Dictionary<string, object?>(StringComparer.Ordinal);

	/// <summary>
	/// A URI reference that identifies the specific occurrence of the problem. It may or may
	/// not yield further information if dereferenced.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-1)]
	[JsonPropertyName("instance")]
	public string? Instance { get; set; }

	/// <summary>
	/// The HTTP status code([RFC7231], Section 6) generated by the origin server for this
	/// occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
	[JsonPropertyOrder(-3)]
	[JsonPropertyName("status")]
	public int StatusCode { get; set; }

	/// <summary>
	/// A short, human-readable summary of the problem type. It SHOULD NOT change from
	/// occurrence to occurrence of the problem, except for purposes of localization(e.g., using
	/// proactive content negotiation; see[RFC7231], Section 3.4).
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-4)]
	[JsonPropertyName("title")]
	public string? Title { get; set; }

	/// <summary>
	/// A URI reference [RFC3986] that identifies the problem type. This specification
	/// encourages that, when dereferenced, it provides human-readable documentation for the
	/// problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not
	/// present, its value is assumed to be "about:blank".
	/// </summary>
	[JsonPropertyOrder(-5)]
	[JsonPropertyName("type")]
	public string Type { get; set; } = "about:blank";

	/// <summary>
	/// Implicitly converts a <see cref="Problem"/> to a <see cref="ProblemException"/>.
	/// </summary>
	/// <param name="problem">
	/// The <see cref="Problem"/> instance to convert.
	/// </param>
	public static implicit operator ProblemException(Problem problem) => new(problem);

	/// <summary>
	/// Converts this <see cref="Problem"/> to a <see cref="ProblemException"/>.
	/// </summary>
	/// <returns>
	/// A new instance of <see cref="ProblemException"/> initialized with this <see cref="Problem"/>.
	/// </returns>
	public ProblemException ToProblemException() => new(this);
}
